syntax = "proto3";

package logging;

message ExperimentRecord {
    repeated EpisodeRecord episode = 1;
    bytes environment = 2;
}

message EpisodeRecord {
    repeated NodeRecord node = 1;  // Contains all node timings
}

message NodeRecord {
    NodeInfo info = 1;
    uint32 sync = 2; // Synchronous (=0), or asynchronous (=1)
    uint32 clock = 3;  // Simulated (=0) or wall-clock (=1)
    float real_time_factor = 4;  // Fast-as-possible (=0), real-time (=1), or any other value > 0.
    float ts_start = 5;  // Wall-clock timestamp of episode start.
    repeated uint32 rng = 6;  // PRNG key (seeds the delay_sim of the output & initial step_state.rng).
    repeated InputRecord inputs = 7; // Input info and timing info on received messages.
    repeated StepRecord steps = 8;  // Timing info on executed steps
    Serialization outputs = 9;  // Serialized output trajectory.
    Serialization rngs = 10;  // Serialized RNG state trajectory.
    Serialization states = 11;  // Serialized state trajectory.
    Serialization params = 12;  // Serialized parameter trajectory.
    Serialization step_states = 13;  // Serialized step_state trajectory. Already includes rng, state, and params.
}

message StepRecord {
    uint32 tick = 1;  // The tick count
    double ts_scheduled = 2; // Expected step start (in zero-delay situation)
    double ts_max = 3; // Maximum timestamp of blocking messages
    double ts_output_prev = 4; // previous output ts (timestamp of last step ending).
    double ts_step = 5; // Step timestamp (after considering any input, scheduling, or last output phase shifts)
    double ts_output = 6; // Timestamp of step ending
    double phase = 7; // Phase shift due to scheduling and/or delays
    double phase_scheduled = 8; // Phase shift due to scheduling and/or delays
    double phase_inputs = 9; //  Phase shift: ts_max - ts_scheduled (can be negative if only blocking inputs)
    double phase_last = 10; // Phase shift: ts_output - ts_scheduled
    Header sent = 11; // Sent timestamp of output message
    double delay = 12; // Simulated computation delay
    Time comp_delay = 13; // Computation delay (sc not accurate if FAST_AS_POSSIBLE)
}

message InputRecord {
    InputInfo info = 1;
    repeated uint32 rng = 2;  // PRNG key (seeds the delay_sim of the input).
    repeated GroupedRecord grouped = 3;
}

message GroupedRecord {
    uint32 num_msgs = 1;
    repeated MessageRecord messages = 2;
}

message MessageRecord {
    Header sent = 1;
    Header received = 2;
    double delay = 3; // Simulated communication delay
    Time comm_delay = 4; // Communication delay (sc not accurate if FAST_AS_POSSIBLE)
}

message Header {
    uint32 eps = 1;
    uint32 seq = 2;
    Time ts = 3;
}

message Time {
    double sc = 1;
    double wc = 2;
}

message GraphInfo {
    repeated NodeInfo nodes = 1; // All nodes within the graph
}

message NodeInfo {
    string name = 1; // Name of the node
    string cls = 2; // Class of the node as a string `module/attribute`
    bytes state = 3; // Pickled state of the node. Can be used to reconstruct the node. See Node.__getstate__ and Node.__setstate__.
    float rate = 4; // Rate of the node
    bool stateful = 5;  // Whether the node is stateful (=True) or stateless (=False).
    bool advance = 6;  // Whether the node may advance its step (=True) or not (=False).
    uint32 scheduling = 7;  // Phase (=0) or frequency (=1)
    float phase = 8; // Phase shift
    GMM delay_sim = 9; // Computation delay distribution of the node step
    float delay = 10; // Computation delay that is taken into account.
    repeated InputInfo inputs = 11;  // Registered inputs
}


message InputInfo {
    string name = 1; // name of the input argument
    string output = 2; // name of the node that produces the output
    float rate = 3; // Rate of connected output
    uint32 window = 4; // Window size
    bool blocking = 5; // Connection type
    bool skip = 6; // True if this input dependency is skipped on initial tick
    uint32 jitter = 7; // Latest (=0) and buffer (=1) (only applies to non-blocking connections)
    float phase = 8; // Phase shift. This sets the "dejitter" buffer size for non-blocking connections.
    GMM phase_dist = 9; // Distribution of the phase shift (provided every node keeps its rate).
    GMM delay_sim = 10; // Communication delay distribution
    float delay = 11; // Communication delay that is taken into account.
}

message GMM {
    repeated Gaussian gaussians = 1;
}

message Gaussian {
    float weight = 1;
    float mean = 2;
    float std = 3;
    float percentile = 4;
    float low = 5;
    float high = 6;
}

message Serialization {
    // Flax serialization of data.
    // Use `flax.serialization.from_bytes(pickle.load(target), encoded_bytes[idx])` to deserialize.
    // If the target cannot be pickled, use `flax.serialization.msgpack_restore(encoded_bytes)` instead to retrieve a state-dict.
    bytes target = 1; // Template object (pickled) with state-dict registrations that matches the structure being deserialized from `encoded_bytes`.
    repeated bytes encoded_bytes = 2; // Encoded bytes (each element in the list can be reconstructed to target).
}

message NetworkRecord{
    repeated EpisodeRecord episode = 1;
    string root = 2; // Root node
    uint32 seq = 3; // Sequence number
    string split_mode = 4; // Split mode (e.g. `topological_generation`)
    string supergraph_mode = 5; // Supergraph mode (e.g. `MCS`, 'topological`)
    repeated string excludes_inputs = 6; // Nodes that exclude their inputs during the trace
    bytes motifs = 7; // Motifs (pickled dict[root_seq, networkx.DiGraph])
    bytes MCS = 8; // Minimum common (monomorphic) supergraph incl. root in last generation (pickled networkx.DiGraph)
}