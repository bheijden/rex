syntax = "proto3";

package logging;


message EpisodeRecord {
    repeated NodeRecord node = 1;  // Contains all node timings
//    repeated TraceRecord trace = 2;  // Records a traced episode
}

message NodeRecord {
    NodeInfo info = 1;
    uint32 sync = 2; // Synchronous (=0), or asynchronous (=1)
    uint32 clock = 3;  // Simulated (=0) or wall-clock (=1)
    uint32 scheduling = 4;  // Phase (=0) or frequency (=1)
    float real_time_factor = 5;  // Fast-as-possible (=0), real-time (=1), or any other value > 0.
    float ts_start = 6;  // Wall-clock timestamp of episode start.
    repeated InputRecord inputs = 8; // Input info and timing info on received messages.
    repeated StepRecord steps = 9;  // Timing info on executed steps
}

message StepRecord {
    uint32 tick = 1;  // The tick count
    double ts_scheduled = 2; // Expected step start (in zero-delay situation)
    double ts_max = 3; // Maximum timestamp of blocking messages
    double ts_output_prev = 4; // previous output ts (timestamp of last step ending).
    double ts_step = 5; // Step timestamp (after considering any input, scheduling, or last output phase shifts)
    double ts_output = 6; // Timestamp of step ending
    double phase = 7; // Phase shift due to scheduling and/or delays
    double phase_scheduled = 8; // Phase shift due to scheduling and/or delays
    double phase_inputs = 9; //  Phase shift: ts_max - ts_scheduled (can be negative if only blocking inputs)
    double phase_last = 10; // Phase shift: ts_output - ts_scheduled
    Header sent = 11; // Sent timestamp of output message
    double delay = 12; // Simulated computation delay
    Time comp_delay = 13; // Computation delay (sc not accurate if FAST_AS_POSSIBLE)
}

message InputRecord {
    InputInfo info = 1;
    repeated GroupedRecord grouped = 2;
}

message GroupedRecord {
    uint32 num_msgs = 1;
    repeated MessageRecord messages = 2;
}

message MessageRecord {
    Header sent = 1;
    Header received = 2;
    double delay = 3; // Simulated communication delay
    Time comm_delay = 4; // Communication delay (sc not accurate if FAST_AS_POSSIBLE)
}

message Header {
    uint32 eps = 1;
    uint32 seq = 2;
    Time ts = 3;
}

message Time {
    double sc = 1;
    double wc = 2;
}

message GraphInfo {
    repeated NodeInfo nodes = 1; // All nodes within the graph
}

message NodeInfo {
    string name = 1; // Name of the node
    float rate = 2; // Rate of the node
    bool stateful = 3;  // Whether the node is stateful (=True) or stateless (=False).
    bool advance = 4;  // Whether the node may advance its step (=True) or not (=False).
    float phase = 5; // Phase shift
    GMM delay = 6; // Computation delay distribution of the node step
    repeated InputInfo inputs = 7;  // Registered inputs
}

message InputInfo {
    string name = 1; // name of the input argument
    string output = 2; // name of the node that produces the output
    float rate = 3; // Rate of connected output
    uint32 window = 4; // Window size
    bool blocking = 5; // Connection type
    bool skip = 6; // True if this input dependency is skipped on initial tick
    uint32 jitter = 7; // Latest (=0) and buffer (=1) (only applies to non-blocking connections)
    float phase = 8; // Phase shift. This sets the "dejitter" buffer size for non-blocking connections.
    GMM phase_dist = 9; // Distribution of the phase shift (provided every node keeps its rate).
    GMM delay = 10; // Communication delay distribution
}

message GMM {
    repeated Gaussian gaussians = 1;
}

message Gaussian {
    float weight = 1;
    float mean = 2;
    float var = 3;
    float percentile = 4;
    float low = 5;
    float high = 6;
}

message TraceRecord {
    EpisodeRecord episode = 1;
    repeated NodeInfo node = 2; // Node info
    StepRecord trace = 3;  // Traced step call
    repeated TracedStep used = 4; // Topologically sorted step calls
    repeated TracedStep excluded = 5; // if the step call was excluded in the trace.
}

message TracedStep {
    bool used = 1;  // Whether the step is required (=True) or not (=False).
    uint32 index = 2; // Index in the topologically sorted computation graph
    uint32 depth = 3; // Depth of the graph
    bool stateful = 4; // Whether the node is stateful (=True) or stateless (=False).
    bool static = 5;    // Whether the node's params are static (=True) or stateless (=False).
    string name = 6; // Node name.
    uint32 tick = 7; // The tick count.
    double ts_step = 8; // Step timestamp (after considering any input, scheduling, or last output phase shifts).
    repeated Dependency upstream = 9; // Upstream dependencies, on which this step call depends.
    repeated Dependency downstream = 10; // Downstream dependencies that depend on this step call.
}

message Dependency {
    bool used = 1;  // Whether the dependency is required (=True) or not (=False).
    Source source = 2;
    Target target = 3;
}

message Source {
    string name = 1;    // Node name.
    uint32 tick = 2;    // Sequence number (=input dependency), or tick of previous step call (= state dependency).
    double ts = 3;      // Sent timestamp of output (=input dependency), or ts_output (= state dependency). ts_output == ts_sent.
}

message Target {
    string name = 1 ;       // Node name.
    string input_name = 2;  // Input name (=input dependency), else None (=state dependency).
    uint32 tick = 3;        // Tick of current step call (=input and state dependency).
    double ts = 4;          // Timestamp of received input message (=input dependency) or ts_step (=state dependency).
    Target rerouted = 5;    // Rerouted target (if any).
}